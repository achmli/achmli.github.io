---
layout:       post
title:        "《见证者》引擎技术博客——一个着色器小技巧"
author:       "Fon"
header-style: text
catalog:      true
tags:
    - 《见证者》博客翻译
    - 图形学
---
> 因为十分喜欢《见证者》，所以想试着翻译一下他们的技术博客。
>
> 大概是最后一篇了。不想翻了，本来突然想翻这些博客就是因为逃避现实不想找工作不想写毕业论文，找不到工作甚至还有可能毕不了业的飞舞研究生压力就是这么大捏。。。反正博客里讲渲染的也差不多都翻了，而且吹哥在这个博客上发的都偏向于效果展示而不是技术介绍和讲解，总之不太想翻了。其实真感兴趣的话吹哥自己的博客里还有[《braid》](https://zhida.zhihu.com/search?content_id=255900844&content_type=Article&match_order=1&q=%E3%80%8Abraid%E3%80%8B&zhida_source=entity)的源码解析。但还好我没兴趣了捏。。。。。。
>
> 另外上一篇文章里也贴了Ignacio Castaño这位老哥的博客，看他的博客是05年去了n开头的显卡公司，09年离职加入了见证者项目组，后来又回去那家显卡公司了，大概这就是大佬吧。。。总之他最新的两篇博客都是[纹理压缩](https://zhida.zhihu.com/search?content_id=255900844&content_type=Article&match_order=1&q=%E7%BA%B9%E7%90%86%E5%8E%8B%E7%BC%A9&zhida_source=entity)这个方向的，感觉这个方向甚至还有点热门，所幸我是一点都不懂捏。。。
>
> 那么吹哥的新游戏什么时候会有呢。以及吹哥的编程语言jai又开发到什么程度了呢。不如看看吹哥的直播听点老牌游戏开发人员的爆论捏。。。。
>
> 这篇完全由ds翻译，我连润色都没做捏，不过也不能这么说，应该说翻完我连看都没看捏直接复制了捏，AI真是我叠捏。找不到工作压力太大了捏，甚至纠结继续找游戏公司还是干脆考公考编之类的算了捏，总之不想自己动脑惹。。。。。
>
> 博客链接：http://the-witness.net/news/category/engine-tech
>
> 原文链接：[A Shader Trick](http://the-witness.net/news/2022/02/a-shader-trick/)
>
> 作者：Jonathan Blow

（今天我在写一封关于我们在着色器系统中使用的一个简单技巧的邮件时，发现这个内容很容易分享且非常实用，所以在此公开！）

当前雾气效果还存在一处时间维度的卡顿问题，修复起来应该很简单，不过其背后的原理可能有点出人意料，所以我将此作为知识分享抄送团队。

关于浮点数运算，普遍存在一个大数加小数时精度丢失的问题——小数部分往往会被截断趋零。这是计算机的固有特性（毕竟我们是用有限内存来模拟实数存储），并非图形学独有。虽然程序员平时不太需要考虑这个问题，但某些特定场景下确实会引发麻烦。

在着色器中，我们经常需要使用由CPU控制的时间变量来生成各种效果。这个时间变量可能从关卡开始或游戏启动时持续累加。若以秒为单位，10分钟后约为600秒，2小时后达7200秒。如果游戏持续运行三天（这是主机平台的认证要求！），这个值会超过25万。

这些数字看起来不算特别大，但当我们同时处理微小数值时就会出问题。假设游戏以60帧运行（对现代PC而言可能算低帧率了），每帧耗时0.017秒。当我们需要同时处理当前时间和帧时间时，两者的比值可达250,000/(1/60)=1500万。这在32位浮点数运算中会产生严重的精度问题——当把增量时间加到当前时间时，微小的增量时间几乎会被完全吞没。远在此之前，你就会开始看到动画抖动、物体位置偏移等异常现象。

解决方案之一是不要让当前时间无限增长，而是在达到某个阈值时重置归零。比如每分钟重置一次，但这样会要求所有特效必须在整分钟边界完美衔接，这对特效调试来说非常痛苦。例如要制作无缝衔接的余弦波特效，必须让波形周期严格等于1分钟、半分钟、1/3分钟等，这既增加了设计人员的工作量（必须时刻注意周期匹配），又因为浮点数无法精确表示这些时间值而引入新的精度问题。

不过图形程序员有个传承已久的巧妙解决方案（我第一次是从《见证者》开发时的Ignacio那里学到的）。以余弦波为例，我们通常会使用cos(freq\*time\*2\*PI)这样的函数。要确保时间重置时波形完美衔接，必须满足cos(freq\*time_max\*2\*PI)=1的条件——即当时间达到最大值时，波形正好完成整数次循环。由于存在2π因子，这等价于要求freq\*time_max必须是整数。

如何简单粗暴地实现这一点？选择time_max为10的整数次幂秒数（比如1000秒）。这样只要频率参数的小数位不超过3位，就能保证乘积为整数。例如freq=9.876时，cos(9.876\*1000\*2\*π)=cos(9876\*2\*π)=1。该机制适用于任意小数点后三位以内的数值。若需要四位精度，只需将time_max设为10000秒即可。当从配置文件中读取数值时，我们可以自动将其四舍五入到指定精度（若舍入误差较大则发出警告提醒设计人员）。

这个技巧适用于所有周期函数（上文仅以余弦为例）。对于UV滚动等线性位移效果，同样需要保证位移速率与time_max的乘积为整数。翻页动画的时间索引参数也遵循相同原理。

当前雾气效果出现卡顿的原因，正是着色器系统每隔1000秒将时间重置归零，而雾气效果没有同步这一机制。这种周期性重置的根本目的，正是为了确保着色器中基于时间的各种效果始终保持良好的运算精度。
