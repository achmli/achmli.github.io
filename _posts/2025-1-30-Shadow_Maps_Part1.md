---
layout:       post
title:        "《见证者》引擎技术博客——Shadow Map第一部分"
author:       "Fon"
header-style: text
catalog:      true
tags:
    - 《见证者》博客翻译
    - 图形学
---
> 因为十分喜欢《见证者》，所以想试着翻译一下他们的技术博客。
>
> 总之它们博客上Engine Tech这个tag里的更新基本上都在2010年到2014年，所以这里面的技术很大可能都已经落后了，突出一个学了可能没啥用。
>
> 不过csm虽然不算多先进，但也是现在的主流。只是应该有很多更好的教程吧。。。。
>
> 博客链接：http://the-witness.net/news/category/engine-tech
>
> 原文链接：[Graphics Tech: Shadow Maps (part 1) – The Witness](http://the-witness.net/news/2010/03/graphics-tech-shadow-maps-part-1/)
>
> 作者：Jonathan Blow

尽管《见证者》中同时有室内和室外的场景，但是游戏是很多时间发生在有很长的视距的户外（如果找到一个好的观景点可以看见完整的岛屿）。所以我先要实现一个足够鲁棒（译：我故意的）的阴影系统，提供高质量的视觉效果，还可以允许玩家同时看到游戏中的一切。我有过制作这种类型的阴影系统的经验，但那是2004年，那时候电脑和显卡性能都还很孱弱。所以我想看看现在（2010年）有多少新的可能性。

我们已经为《见证者》实现这样的现代现代的shadow map系统。在这个过程中，我们对现有的shadow mapping算法做了一些改进，超过了我们知道的那些已发布的成果（2010年），所以我们打算详细介绍这些改进。不过我们并没有停止对shadow mapping的改进，所以我也会谈论我们打算做的一些尝试和我认为这些值得一试的理由。

在我们谈论这些细节之前，我想说一些背景，以便解释清楚做出这些设计决策的动机。

## 文献

我对图形学的研究文献始终有一种相对谨慎的态度：它们中大部分描述的技术往往并不会真正可行，但是这些论文的作者又不遗余力地将这些技术“兜售”给你（比如只展示特定的示例，忽略那些失败案例）。作为读者，如果你一开始就知道最终效果就不会感觉被冒犯了，但往往你需要耗费大量的时间（甚至是几个月）和精力理解和实现这些算法，然后才发现效果是如此之差。

我已经有过好几次这样的经验了，还是在许多不同的技术上。很不幸，shadow map也是其中的一个。有很多发表的shadow map技术效果差到不值得严肃看待。我常常听到有人说“这个或者那个阴影技术很棒”，这通常由于它们并没有自己尝试使用过，所以要么这只是传闻，要么就是他们的标准很低。

因此我需要明确一点，我的标准很高，只会推荐那些功能被验证是鲁棒的技术。我会开放和诚实地指出那些存在问题的技术，以及具体是什么问题。在理想的世界中，这是没有必要的，但是现在的学术环境迫使我不得不这么做。

## 目标质量和之前的系统

之前许多的shadow map方案都通过高度依赖视角的变换来最大化场景中阴影的有效分辨率。perspective shadow maps是其中一个极端的例子。过去的经验让我选择不去使用它们。这些算法常常导致阴影有烦人的闪烁和游动，而且其中很多算法在玩家处于特定的视角时产生严重的崩溃。

在我2004年设计的系统中，我设定了一个核心目标，那就是那些在非移动物体上的阴影应该十分稳定，坚如磐石，无论玩家的视点怎么移动，都不会改变。实现这个目标最清晰的方法就是将视点设置为shadow map的中心，并且永远不让shadow map缩放和旋转。由于单张shadow map因为内存和填充限制无法覆盖整个游戏世界，所以我使用了一种名为“square doughnut”的方案，以视点为中心生成四张或者更多的shadow map，覆盖范围逐步增大。为了防止出现阴影爬动和闪烁的情况，需要保证shadow map的世界空间位置必须对其为贴图像素大小的整数倍。（有一个相关的技术，只是不把视点作为中心，后来被十分广泛地应用，被称为级联阴影贴图(Cascaded Shadow Maps)）。

在固定管线的硬件上，这个方案的效果总是不能让人满意（我不得不使用裁剪平面(clip plane)来将场景渲染成许多切片(slice)，但由于精度的原因会有1像素大小的artifact，而且渲染多个切片过于缓慢）。现代的硬件已经可以将这些事做的很好了，但是这个方案会浪费大量的shadow map的空间，由于这些shadow map都是以视点为中心，所以无论什么时候shadow map上大多数像素都是在视角外的。

抛开这些缺点，这项技术的视觉稳定性和它能覆盖整个世界的能力对我十分有吸引力。在看过shadow mapping在实践中可以有如此优秀的表现后，这样的视觉稳定性成为了我对将来的阴影系统中非常高优先级的目标。

所以，对于新的阴影系统，我的目标按重要性顺序排序如下：

1. 高性能
2. 在相机移动时的稳定性
3. 长视距
4. 视觉效果可控，可以调整到适应游戏的风格
5. 纹理存储空间的利用效率。

## 新系统

我在新系统的工作开始于改善2004年那个系统的内存利用率。但这样会导致shadow map在世界空间中移动，我最初不清楚怎么做能避免移动后可能出现的问题。直到Ignacio向我推荐了ShaderX 6上Michal Valient发表的一篇标题为“Stable Rendering of Cascaded Shadow Maps”的文章。他计算出包围视锥体切片( slices of the view frustum)的包围球，这些球告诉他可以在世界空间中移动Shadow Map多远而不会碰上shadow map层级间的间隙。

为了详细地说明，我在这里放了几张从他文章里偷来的几张图片。我无意侵犯任何人的版权，所以如果你对边缘切割(cutting-edge) shadow map技术感兴趣，那么请去购买ShaderX 6.

![thumbs_figure_411](https://raw.githubusercontent.com/achmli/achmli.github.io/master/img/witness/2/thumbs_figure_411.png)

![thumbs_figure_412](https://raw.githubusercontent.com/achmli/achmli.github.io/master/img/witness/2/thumbs_figure_412.png)

这个方法的基本原理是，从世界空间中获得一个视锥体切片，计算能包围这个切片的最小的包围球的大小，然后再计算最小的立方体（译：原文是square cylinder）包围住包围球，然后正方形就是shadow map了。

你可以将多个视锥体切片渲染到多张shadow map上，只要不同层级的包围球的重叠足以覆盖完成的视锥体。

我们使用包围球的原因是：shadow map的大小是固定的（我们主动添加了这个限制以获得更加稳定的阴影），然后我们需要找到一种能稳定地闭包摄像机旋转时视锥体在空间中所有可能的方向的形状。那就是球了。再然后我们就需要保证我们shadow map能够覆盖完整的包围球，这样才能保证视锥体中的每个点都被一个有效的shadow map上的像素覆盖。

此外，Valient还给出了一个非常有用的优化建议，那就是将所有的shadow map打包成一张图集(atlas)纹理，这样当你需要去渲染完整的场景时，你可以在一个pass里渲染所有阴影，而不需要去采样多张shadow map。你只需要弄清shadow map上的每个像素对应在哪个视锥体切片中，然后用这些信息确定采样坐标的偏移量，在采样时坐标上加上这个偏移量。这非常有效。Valient建议贴图用2\*2的形式排列，这样在大多数的硬件设备上实现起来比较方便，比如那些只支持2的平方的数量的贴图的显卡。如果单张shadow map的分辨率是1024\*1024，就可以创建一张2048\*2048分辨的纹理来容纳4张shadow map，并将它们打包成一个2\*2的数组（译：现在的贴图数组不是这个意思吧大概）：

![4maps](https://raw.githubusercontent.com/achmli/achmli.github.io/master/img/witness/2/4maps.png)

所以我在新系统上的第一个工作基本上就是把Valient描述的东西重新实现了一遍。这没有花费我很多时间，完成后，我也感到十分高兴——因为它明显比2004年那个系统要好上不少。

但是。。。

## 内存使用

这项技术依然十分消耗内存空间。由于我们对视觉稳定性而产生的约束，导致我们先要将视锥体切片放在一个球里，再把球放到一个盒子里，每一步都增加了不少不使用或者几乎不使用的纹理空间，从上面那张标号是4.1.2的图里也能看出来，一个视锥体切片几乎只占正方形中的50%~60%，这说明这里面有将近一半的空间是被浪费的。但是，真实的情况比这还要糟，因为这张图存在一定的误导性。

问题就是，图中所画的视锥体要比游戏中实际的视锥题要窄的多，如果用实际的比例重新绘制图片，看上去会大不相同。对于一个准确的2D图片，你找到包围视锥体中最款部分的圆是通过视锥体切片截面的梯形的对角线（Valient在他的文章中也提到了这点）。假设你的游戏用16:9的宽高比运行，并且FOV是水平方向90度（这是《见证者》目前的设置），那么垂直防线的FOV就是大约59度，对角线的FOV就大约是98度，具体计算放在下面的图中：

![diagonal_fov](https://raw.githubusercontent.com/achmli/achmli.github.io/master/img/witness/2/diagonal_fov.png)

Valient的图中的视锥体切片的角度大约是30度，这是多大的差别！所以如果我们的视锥体切片是98度，把他放进一个圆里，再把圆放进正方形里，看起来会是什么样子？就像这样：

![1slice](https://raw.githubusercontent.com/achmli/achmli.github.io/master/img/witness/2/1slice.png)

回想一下，正方形是你的shadow map，而你的视锥体切片是最里面那个梯形（可能会被使用到的shadow map上的像素）。它只覆盖了正方形中非常小的一部分——还没有方法能让它变大！对于这个么宽的视锥体，它在远平面的对角线会非常长，长到包围球的计算被它主导了，球心必须落在这条对角线上，球才能刚搞能完全包住视锥体（在《见证者》中，我们的视锥体切片并不是完全按比例的，我们划分它们的方式使得前两个阴影贴图不是完美地符合这一点，但是很接近）。球心在这条对角线上意味着浪费了一般的空间，而广角一位置另外一半中大部分也一样被浪费了！

你可以通过旋转视锥体来让它看起来覆盖了shadow map中更多的部分。比如你把视锥体旋转到观察向量(view vector)垂直指向屏幕内，那么视锥体的投影看上去就会是一个矩形，这样看上去会提高覆盖率。但你要明白，就对场景的影响而言，有一些覆盖比其他的更有价值。想一下有多少空间是被那些指向视锥体中央的像素覆盖的，与指向边缘的像素数量做对比（几乎没有！译：应该指视锥体中央的部分在投影后会被边缘的部分覆盖）

如果我再加上两个视锥体切片，就像图4.1.2中那样总共三个，它看上去会像这样，

![3slices](https://raw.githubusercontent.com/achmli/achmli.github.io/master/img/witness/2/3slices.png)

最内侧的shadow map只是很小的一块（现在你知道为什么Valient要选这么狭窄的FOV了——为了你能看清楚那张图！）。但也请你注意：每一张shadow map都完整地被包含在下一层级更大shadow map中，就像我那个2004年的老系统，Valient的方案只是好在提供了更大的视距（因为不是同心的），但又因为超广角的FOV，它也无法提供他想要的那么远的视距。

## 下一步

总而言之，我对这个阴影系统的性能和视觉表现很满意，但是它仍然在内存使用上有些浪费了。下一次，我会讨论怎么定位这个问题。将来的推文中，我也会讨论怎么软化阴影的边缘，视锥体切片的边缘的过度和其他一些各种各样的实现上的技巧。

`<b>`待续 `</b>`
